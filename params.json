{"name":"I18next-scanner","tagline":"i18next-scanner is a transfrom stream that can scan your code, extract translation keys/values, and merge them into i18n resource files.","body":"# i18next-scanner [![build status](https://travis-ci.org/cheton/i18next-scanner.svg?branch=master)](https://travis-ci.org/cheton/i18next-scanner)\r\n\r\n[![NPM](https://nodei.co/npm/i18next-scanner.png?downloads=true&stars=true)](https://nodei.co/npm/i18next-scanner/)\r\n\r\ni18next-scanner is a transfrom stream that can scan your code, extract translation keys/values, and merge them into i18n resource files.\r\n\r\nIt's available as both Gulp and Grunt plugins.\r\n\r\n## Features\r\n* Fully compatible with [i18next](https://github.com/i18next/i18next) - a full-featured i18n javascript library for translating your webapplication.\r\n* Support [i18next-text](https://github.com/cheton/i18next-text) to write your code without maintaining i18n keys.\r\n* A transform stream that works with both Gulp and Grunt task runner.\r\n* Support custom transform and flush functions.\r\n\r\n## Installation\r\n```\r\nnpm install i18next-scanner\r\n```\r\n\r\n## API\r\n```\r\nfunction(options[, customTransform[, customFlush]])\r\n```\r\n\r\n### options\r\n```javascript\r\n{\r\n    lngs: ['en'],\r\n    sort: false,\r\n    defaultValue: '',\r\n    resGetPath: 'i18n/__lng__/__ns__.json',\r\n    resSetPath: 'i18n/__lng__/__ns__.json',\r\n    nsseparator: ':',\r\n    keyseparator: '.',\r\n    interpolationPrefix: '__',\r\n    interpolationSuffix: '__',\r\n    ns: {\r\n        namespaces: [],\r\n        defaultNs: 'translation'\r\n    }\r\n}\r\n```\r\n\r\n#### lngs\r\n\r\nType: `Array` Default: `['en']`\r\n\r\nProvides a list of supported languages by setting the lngs option.\r\n\r\n#### sort\r\n\r\nType: `Boolean`  Default: `false`\r\n\r\nSet to `true` if you want to sort translation keys in ascending order.\r\n\r\n#### defaultValue\r\n\r\nType: `String` Default: `''`\r\n\r\nProvides a default value if a value is not specified.\r\n\r\n#### resGetPath\r\n\r\nType: `String` Default: `'i18n/__lng__/__ns__.json'`\r\n\r\nThe source path of resource files. The `resGetPath` is relative to current working directory.\r\n\r\n#### resSetPath\r\n\r\nType: `String` Default: `'i18n/__lng__/__ns__.json'`\r\n\r\nThe target path of resource files. The `resSetPath` is relative to current working directory or your `gulp.dest()` path.\r\n\r\n#### nsseparator\r\n\r\nType: `String` Default: `':'`\r\n\r\nThe namespace separator.\r\n\r\n#### keyseparator\r\n\r\nType: `String` Default: `'.'`\r\n\r\nThe key separator.\r\n\r\n#### interpolationPrefix\r\n\r\nType: `String` Default: `'__'`\r\n\r\nThe prefix for variables.\r\n\r\n#### interpolationSuffix\r\n\r\nType: `String` Default: `'__'`\r\n\r\nThe suffix for variables.\r\n\r\n#### ns\r\n\r\nType: `Object` or `String`\r\n\r\nIf an `Object` is supplied, you can either specify a list of namespaces, or override the default namespace.\r\nFor example:\r\n```javascript\r\n{\r\n    ns: {\r\n        namespaces: [ // Default: []\r\n            'resource',\r\n            'locale'\r\n        ],\r\n        defaultNs: 'resource' // Default: 'translation'\r\n    }\r\n}\r\n```\r\nIf a `String` is supplied instead, it will become the default namespace.\r\nFor example:\r\n```javascript\r\n{\r\n    ns: 'resource' // Default: 'translation'\r\n}\r\n```\r\n\r\n### customTransform\r\nThe optional `customTransform` function is provided as the 2nd argument. It must have the following signature: `function (file, encoding, done) {}`. A minimal implementation should call the `done` function to indicate that the transformation is done, even if that transformation means discarding the file.\r\nFor example:\r\n```javascript\r\nvar customTransform = function _transform(file, enc, done) {\r\n    var parser = this.parser;\r\n    var extname = path.extname(file.path);\r\n    var content = fs.readFileSync(file.path, enc);\r\n\r\n    // add custom code\r\n\r\n    done();\r\n};\r\n```\r\n\r\nTo parse a translation key, call `this.parser.parseKey(key, defaultValue)`. The `defaultValue` is optional if the key is not assigned with a default value.\r\nFor example:\r\n```javascript\r\nvar _ = require('lodash');\r\nvar customTransform = function _transform(file, enc, done) {\r\n    var parser = this.parser;\r\n    var content = fs.readFileSync(file.path, enc);\r\n    var results = [];\r\n\r\n    // parse the content and loop over the results\r\n\r\n    _.each(results, function(result) {\r\n        parser.parseKey(result.key, result.defaultValue || '');\r\n    });\r\n};\r\n```\r\n\r\nAlternatively, you may call `this.parser.parseValue(value, defaultKey)` to parse a text string with a default key. The `defaultKey` should be unique string and can never be `null`, `undefined`, or empty.\r\nFor example:\r\n```javascript\r\nvar _ = require('lodash');\r\nvar customTransform = function _transform(file, enc, done) {\r\n    var parser = this.parser;\r\n    var content = fs.readFileSync(file.path, enc);\r\n    var results = [];\r\n\r\n    // parse the content and loop over the results\r\n\r\n    _.each(results, function(result) {\r\n        var defaultKey = sha1(result.value); // returns a SHA-1 hash value as its default key\r\n        parser.parseValue(result.value, result.defaultKey || defaultKey);\r\n    });\r\n};\r\n```\r\n\r\n### customFlush\r\nThe optional `customFlush` function is provided as the last argument, it is called just prior to the stream ending. You can override the default `flush` function to process \r\nFor example:\r\n```javascript\r\nvar _ = require('lodash');\r\nvar customFlush = function _flush(done) {\r\n    var that = this;\r\n    var resStore = parser.toObject({\r\n        sort: !!parser.options.sort\r\n     });\r\n\r\n    // loop over the resStore\r\n    _.each(resStore, function(namespaces, lng) {\r\n        _.each(namespaces, function(obj, ns) {\r\n            // add custom code\r\n        });\r\n    });\r\n    \r\n    done();\r\n};\r\n```\r\n\r\n## Gulp Usage\r\n\r\n```javascript\r\nvar gulp = require('gulp');\r\n\r\ngulp.task('i18next-scanner', function() {\r\n    var i18next = require('i18next-scanner');\r\n\r\n    return gulp.src(['src/**/*.{js,html}'], {base: 'src'})\r\n        .pipe(i18next({\r\n            lngs: ['en', 'de'],\r\n            defaultValue: '__STRING_NOT_TRANSLATED__',\r\n            resGetPath: 'assets/i18n/__lng__/__ns__.json',\r\n            resSetPath: 'i18n/__lng__/__ns__.json',\r\n            ns: 'translation'\r\n        })\r\n        .pipe(gulp.dest('assets'));\r\n});\r\n```\r\n\r\n### Customize transform and flush functions\r\nThe main entry function of [i18next-scanner](https://github.com/cheton/i18next-scanner/) is a transform stream using [through2](https://github.com/rvagg/through2). You can pass in your `transform` and `flush` functions like so:\r\n```javascript\r\ngulp.src(['src/**/*.{js,html}'], {base: 'src'})\r\n    .pipe(i18next(options, customTransform, customFlush)\r\n    .pipe(gulp.dest('assets'));\r\n```\r\n\r\n### Usage with i18next-text\r\n\r\n#### Example of parsing strings\r\n```javascript\r\nvar _ = require('lodash');\r\nvar hash = require('i18next-text').hash['sha1'];\r\nvar customTransform = function(file, enc, done) {\r\n    var parser = this.parser;\r\n    var extname = path.extname(file.path);\r\n    var content = fs.readFileSync(file.path, enc);\r\n\r\n    /*\r\n     * i18n._('This is text value');\r\n     * i18n._(\"text\"); // result matched\r\n     * i18n._('text'); // result matched\r\n     * i18n._(\"text\", { count: 1 }); // result matched\r\n     * i18n._(\"text\" + str); // skip run-time variables\r\n     */\r\n    (function() {\r\n        var results = content.match(/i18n\\._\\((\"[^\"]*\"|'[^']*')\\s*[\\,\\)]/igm) || '';\r\n        _.each(results, function(result) {\r\n            var key, value;\r\n            var r = result.match(/i18n\\._\\((\"[^\"]*\"|'[^']*')/);\r\n\r\n            if (r) {\r\n                value = _.trim(r[1], '\\'\"');\r\n                key = hash(value); // returns a hash value as its default key\r\n                parser.parseValue(value, key);\r\n            }\r\n        });\r\n    }());\r\n\r\n    done();\r\n};\r\n```\r\n\r\n#### Handlebars i18n helper with block expressions\r\n\r\n```javascript\r\nvar _ = require('lodash');\r\nvar hash = require('i18next-text').hash['sha1'];\r\nvar customTransform = function(file, enc, done) {\r\n    var parser = this.parser;\r\n    var extname = path.extname(file.path);\r\n    var content = fs.readFileSync(file.path, enc);\r\n\r\n    /*\r\n     * {{i18n 'bar'}}\r\n     * {{i18n 'bar' defaultKey='foo'}}\r\n     * {{i18n 'baz' defaultKey='locale:foo'}}\r\n     * {{i18n defaultKey='noval'}}\r\n     */\r\n    (function() {\r\n        var results = content.match(/{{i18n\\s+(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*')?([^}]*)}}/gm) || [];\r\n        _.each(results, function(result) {\r\n            var key, value;\r\n            var r = result.match(/{{i18n\\s+(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*')?([^}]*)}}/m) || [];\r\n\r\n            if ( ! _.isUndefined(r[1])) {\r\n                value = _.trim(r[1], '\\'\"');\r\n            }\r\n\r\n            var params = parser.parseHashArguments(r[2]);\r\n            if (_.has(params, 'defaultKey')) {\r\n                key = params['defaultKey'];\r\n            }\r\n                \r\n            if (_.isUndefined(key) && _.isUndefined(value)) {\r\n                return;\r\n            }\r\n\r\n            if (_.isUndefined(key)) {\r\n                key = hash(value); // returns a hash value as its default key\r\n                parser.parseValue(value, key);\r\n                return;\r\n            }\r\n                \r\n            parser.parseKey(key, value);\r\n        });\r\n    }());\r\n\r\n    /*\r\n     * {{#i18n}}Some text{{/i18n}}\r\n     * {{#i18n this}}Description: {{description}}{{/i18n}}\r\n     * {{#i18n this last-name=lastname}}{{firstname}} ${last-name}{{/i18n}}\r\n     */\r\n    (function() {\r\n        var results = content.match(/{{#i18n\\s*([^}]*)}}((?:(?!{{\\/i18n}})(?:.|\\n))*){{\\/i18n}}/gm) || [];\r\n        _.each(results, function(result) {\r\n            var key, value;\r\n            var r = result.match(/{{#i18n\\s*([^}]*)}}((?:(?!{{\\/i18n}})(?:.|\\n))*){{\\/i18n}}/m) || [];\r\n\r\n            if ( ! _.isUndefined(r[2])) {\r\n                value = _.trim(r[2], '\\'\"');\r\n            }\r\n\r\n            if (_.isUndefined(value)) {\r\n                return;\r\n            }\r\n\r\n            key = hash(value); // returns a hash value as its default key\r\n            parser.parseValue(value, key);\r\n        });\r\n    }());\r\n\r\n    done();\r\n};\r\n```\r\n\r\n## Grunt Usage\r\n~TBD~\r\n\r\n## License\r\n\r\nCopyright (c) 2015 Cheton Wu\r\n\r\nLicensed under the [MIT License](https://github.com/cheton/i18next-scanner/blob/master/LICENSE).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}